# 5. Permutations (Rearrangement)

## What is a Permutation?

A permutation is a rearrangement of elements. The order changes, but the elements themselves remain the same.

---

## Visual Understanding

```
Original array: [1, 2, 3]

All possible permutations:
┌─────────┐
│ 1  2  3 │
│ 1  3  2 │
│ 2  1  3 │
│ 2  3  1 │
│ 3  1  2 │
│ 3  2  1 │
└─────────┘

Total: 3! = 6 permutations
```

---

## Key Property

**Permutations do NOT change:**
- The elements present
- The frequency of each element
- The multiset of values

**Permutations DO change:**
- The order of elements
- Positional relationships

---

## Generating All Permutations

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<int> arr = {1, 2, 3};
    
    // Sort first for next_permutation
    sort(arr.begin(), arr.end());
    
    cout << "All permutations:\n";
    do {
        for (int x : arr) {
            cout << x << " ";
        }
        cout << "\n";
    } while (next_permutation(arr.begin(), arr.end()));
    
    return 0;
}
```

**Output:**
```
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```

---

## Permutations with Duplicates

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<int> arr = {1, 1, 2};
    
    sort(arr.begin(), arr.end());
    
    cout << "All unique permutations:\n";
    do {
        for (int x : arr) {
            cout << x << " ";
        }
        cout << "\n";
    } while (next_permutation(arr.begin(), arr.end()));
    
    return 0;
}
```

**Output:**
```
1 1 2
1 2 1
2 1 1
```

---

## Checking If One Array is Permutation of Another

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

bool isPermutation(vector<int> a, vector<int> b) {
    if (a.size() != b.size()) return false;
    
    sort(a.begin(), a.end());
    sort(b.begin(), b.end());
    
    return a == b;
}

int main() {
    vector<int> arr1 = {1, 2, 3};
    vector<int> arr2 = {3, 1, 2};
    vector<int> arr3 = {1, 2, 4};
    
    cout << "arr1 and arr2: " << (isPermutation(arr1, arr2) ? "Permutation" : "Not") << "\n";
    cout << "arr1 and arr3: " << (isPermutation(arr1, arr3) ? "Permutation" : "Not") << "\n";
    
    return 0;
}
```

---

## Finding Best Permutation (Example: Maximum Sum)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4};
    
    // For maximum sum of adjacent products, sort in specific order
    sort(arr.begin(), arr.end());
    
    int max_sum = 0;
    do {
        int sum = 0;
        for (int i = 0; i < arr.size() - 1; i++) {
            sum += arr[i] * arr[i+1];
        }
        max_sum = max(max_sum, sum);
    } while (next_permutation(arr.begin(), arr.end()));
    
    cout << "Maximum sum of adjacent products: " << max_sum << "\n";
    
    return 0;
}
```

---

## Permutation Patterns

### Creating Alternating Small-Large Pattern

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6};
    sort(arr.begin(), arr.end());
    
    vector<int> result;
    int left = 0, right = arr.size() - 1;
    
    while (left <= right) {
        if (result.size() % 2 == 0) {
            result.push_back(arr[left++]);
        } else {
            result.push_back(arr[right--]);
        }
    }
    
    cout << "Alternating pattern: ";
    for (int x : result) {
        cout << x << " ";
    }
    // Output: 1 6 2 5 3 4
    
    return 0;
}
```

---

## Visual: Rearrangement Impact

```
Original: [3, 1, 4, 2]

After sorting (one permutation):
[1, 2, 3, 4]

After reversing (another permutation):
[4, 3, 2, 1]

Alternating arrangement (another permutation):
[1, 4, 2, 3]

Same elements, different orders!
```

---

## Counting Permutations

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int factorial(int n) {
    int result = 1;
    for (int i = 2; i <= n; i++) {
        result *= i;
    }
    return result;
}

int main() {
    vector<int> arr = {1, 2, 3, 4};
    
    int n = arr.size();
    int total_permutations = factorial(n);
    
    cout << "Total permutations of " << n << " distinct elements: " << total_permutations << "\n";
    // Output: 24
    
    return 0;
}
```

---

## Permutation in Competitive Programming Context

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    // Problem: Can we rearrange array to satisfy some condition?
    
    vector<int> arr = {1, 2, 1, 3};
    
    // Example: Check if we can arrange so all adjacent pairs are different
    sort(arr.begin(), arr.end());
    
    bool valid = true;
    for (int i = 1; i < arr.size(); i++) {
        if (arr[i] == arr[i-1]) {
            valid = false;
            break;
        }
    }
    
    if (valid) {
        cout << "Can arrange with all adjacent different\n";
    } else {
        cout << "Cannot arrange\n";
    }
    
    return 0;
}
```
